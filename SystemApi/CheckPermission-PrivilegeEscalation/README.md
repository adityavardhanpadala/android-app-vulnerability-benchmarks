# Summary
Apps that use *checkCallingPermission* to verify access control are vulnerable
to privilege escalation attacks.  

# Android versions affected
Tested on Android 4.2 - Android 7.1

# Description of vulnerability and corresponding exploit
Every Android app runs in its own process with a unique Process ID (PID) and a unique User ID(UID). In fact all components of an Android app run in the same process with the same PID and UID unless specified otherwise. Components in an Android app can be protected by permissions. If a component is protected by a permission then only components that are granted the permission are allowed to call that component. A permission can be checked at compile time or at run time or both. If a permission is checked at compile time then, components running in the same process as that of the *component protected by the permission* are granted the permission by default. But components running outside that process will have to request the Android system to grant permission to it. However, if the permission is checked at run-time then all components irrespective of whether they run in the same process or not have to request the Android system to grant it permission. Android provides numerous API methods to help verify permissions at run-time. One of these methods is *checkCallingPermission(String permission, String pid, String uid)* which evaluates to true if permission has been granted to a component with PID *pid* and UID *uid*. It returns false otherwise.


*Issue:* A component that uses *checkCallingPermission* to verify access control at run-time, will need to need to obtain the *PID* and *UID* of the calling component before calling *checkCallingPermission*. The *Binder* API provides methods *getCallingPID()* and *getCallingUID()* to determine the calling component's PID and UID respectively. However, both these methods do not always return the calling PID and calling UID. When an application is started, the system creates a thread of execution for the application called *main*. The system does not create a separate thread for each instance of a component. All components that run in the same process are instantiated in the UI thread, and system calls to each component are dispatched from that thread. If *Binder.getCallingPID()* and *Binder.getCallingPID()* are called from the *main* thread, they do not return the PID and UID of the process in which the calling component is running. Instead, they return the PID and UID of the process in which the *protected component* is running in. In such a scenario, if the process in which the *protected component* is running in is granted permission, then *checkCallingPermission* will always evaluate to true. A malicious component can exploit this vulnerability to gain access to the *protected component*.

*Example:* An example of such a vulnerability is shown in *checkCallingPermission-PrivilegeEscalation/Benign*. This app is a benign app and has a service *MyService* that performs a sensitive operation. The app's *MainActivity* requests the user for permission to start *MyService*. If the user grants the permission then *MainActivity* starts the service. *checkCallingPermission-PrivilegeEscalation/Malicious* is a malicious app that also attempts to start *Benign/MyService*. The attempt will be successful because *Benign/MyService* uses *checkPermission("santos.benign.permission",Binder.getCallingPid(),Binder.getCallingUid())* which evaluates to true because permission was already granted to *Benign/MainActivity* before. Therefore, the malicious app can successfully perform a privilege escalation attack.


# Steps to re-produce the exploit automatically
Coming soon.
