# Summary
Apps that use *enforceCallingOrSelfPermission* to verify access control are vulnerable
to privilege escalation attacks.  

# Android versions affected
Tested on Android 4.2 - Android 7.1

# Description of vulnerability and corresponding exploit
Every Android app runs in its own process with a unique Process ID (PID) and a unique User ID(UID). In fact all components of an Android app run in the same process with the same PID and UID unless specified otherwise. Components in an Android app can be protected by permissions. If a component is protected by a permission then only components that are granted the permission are allowed to call that component. A permission can be enforced at compile time or at run time or both. If a permission is enforced at compile time then, components running in the same process as that of the *component protected by the permission* are granted the permission by default. But components running outside that process will have to request the Android system to grant permission to it. However, if the permission is enforced at run-time then all components irrespective of whether they run in the same process or not have to request the Android system to grant it permission. Android provides numerous API methods to help verify permissions at run-time. One of these methods is *enforceCallingOrSelfPermission(String permission, String message)* which throws *SecurityException* if permission has not been granted to a component that runs in the same process as that of the *component protected by the permission* **and** if permission has not been granted to a component that *does not* run in the same process as that of the *component protected by the permission*.


*Issue:* A component that enforces run-time permission checking via *enforceCallingOrSelfPermission* for access control, grants permission to **all** components if it grants permission even once to a component that runs in the same process as that of itself. If *enforceCallingOrSelfPermission* is used to protect a component that performs a sensitive operation then it is possible for a malicious component running in a different process to escalate its privilege and access a component to which the malicious component did not have access to.  

*Example:* An example of such a vulnerability is shown in *EnforceCallingOrSelfPermission-PrivilegeEscalation/Benign*. This app is a benign app and has a service *MyService* that performs a sensitive operation. The app's *MainActivity* requests the user for permission to start *MyService*. If the user grants the permission then *MainActivity* starts the service. *enforceCallingOrSelfPermission-PrivilegeEscalation/Malicious* is a malicious app that also attempts to start *Benign/MyService*. The attempt will be successful because *Benign/MyService* uses *enforceCallingOrSelfPermission* which does not throw a *SecurityException* because permission was already granted to *Benign/MainActivity* before. Therefore, the malicious app can successfully perform a privilege escalation attack.


# Steps to build the sample apps and re-produce the exploit

1. list targets:

    $ android list targets

2. available Android Virtual Devices:

    $ android list avd

3.  create an emulator:

    $ android create avd -n <name> -t <target>

4.  start emulator:

    $ emulator -avd <avd_name>

5. build and install *Benign*:

    $ cd Benign

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk. Build will fail without this.

    $ ./gradlew installDebug

6.  build and install *Malicious*:

    $ cd Malicious

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk. Build will fail without this.

    $ ./gradlew installDebug

7. Launch *Malicious* in the emulator where it is installed.

8.  adb logcat -d | grep "MyService"

    You should see a message "do something important"
