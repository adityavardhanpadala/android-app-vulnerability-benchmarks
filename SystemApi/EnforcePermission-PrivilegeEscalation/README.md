# Summary
Apps that use *enforceCallingPermission* to verify access control are vulnerable
to privilege escalation attacks.  

# Android versions affected
Tested on Android 4.2 - Android 7.1

# Description of vulnerability and corresponding exploit
Every Android app runs in its own process with a unique Process ID (PID) and a unique User ID(UID). In fact all components of an Android app run in the same process with the same PID and UID unless specified otherwise. Components in an Android app can be protected by permissions. If a component is protected by a permission then only components that are granted the permission are allowed to call that component. A permission can be enforced at compile time or at run time or both. If a permission is enforced at compile time then, components running in the same process as that of the *component protected by the permission* are granted the permission by default. But components running outside that process will have to request the Android system to grant permission to it. However, if the permission is enforced at run-time then all components irrespective of whether they run in the same process or not have to request the Android system to grant it permission. Android provides numerous API methods to help verify permissions at run-time. One of these methods is *enforceCallingPermission(String permission, String pid, String uid)* which throws a security exception if permission has not been granted to a component with PID *pid* and UID *uid*.


*Issue:* A component that uses *enforceCallingPermission* to verify access control at run-time, will need to need to obtain the *PID* and *UID* of the calling component before calling *enforceCallingPermission*. The *Binder* API provides methods *getCallingPID()* and *getCallingUID()* to determine the calling component's PID and UID respectively. However, both these methods do not always return the calling PID and calling UID. When an application is started, the system creates a thread of execution for the application called *main*. The system does not create a separate thread for each instance of a component. All components that run in the same process are instantiated in the UI thread, and system calls to each component are dispatched from that thread. If *Binder.getCallingPID()* and *Binder.getCallingPID()* are called from the *main* thread, they do not return the PID and UID of the process in which the calling component is running. Instead, they return the PID and UID of the process in which the *protected component* is running in. In such a scenario, if the process in which the *protected component* is running in, is granted permission, then *enforceCallingPermission* will never throw a Security Exception. A malicious component can exploit this vulnerability to gain access to the *protected component*.

*Example:* This vulnerability is demonstrated by *Benign*  and *Malicious*. The benign app has a service *MyService* that performs a sensitive operation. The app's *MainActivity* requests the user for permission to start *MyService*. If the user grants the permission then *MainActivity* starts the service. *Malicious* is a malicious app that also attempts to start *Benign/MyService*. The attempt will be successful because *Benign/MyService* uses *enforcePermission("santos.benign.permission",Binder.getCallingPid(),Binder.getCallingUid())* which does not throw a security exception because permission was already granted to *Benign/MainActivity* before. Therefore, the malicious app can successfully perform a privilege escalation attack.


# Steps to build the sample apps and to exploit the vulnerability

1. list targets:

    `$ android list targets`

2. list available Android Virtual Devices:

    `$ android list avd`

3.  create an emulator:

    `$ android create avd -n <name> -t <target>`

    *<target>* is obtained from the command listed in 1. *<name>* is the name you choose to give to the avd.

4.  start emulator:

    `$ emulator -avd <avd_name>`

    *<avd-name>* is obtained from the command listed in 2.

5. build and install *Benign*:

    `$ cd Benign`

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk. Build will fail without this.

    `$ ./gradlew installDebug`

6.  build and install *Malicious*:

    `$ cd Malicious`

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk. Build will fail without this.

    `$ ./gradlew installDebug`

7. Launch *Malicious* in the emulator where it is installed.

8.  `adb logcat -d | grep "MyService"`

    You should see a message "do something important"

# References

1.  [Official Android Documentation](https://developer.android.com/reference/android/content/Context.html#enforcePermission(java.lang.String, int, int, java.lang.String))

2.  [How to get CallingUid() and CallingPid()](https://developer.android.com/reference/android/os/Binder.html#getCallingPid())

3.  [Processes and Threads in Android](https://developer.android.com/guide/components/processes-and-threads.html)
