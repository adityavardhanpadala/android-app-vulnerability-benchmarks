# Summary
Apps that use *checkCallingOrSelfPermission* to verify access control are vulnerable
to privilege escalation attacks.  

# Android versions affected
Tested on Android 4.4 - Android 7.1

# Description of vulnerability and corresponding exploit
Every Android app runs in its own process with a unique Process ID (PID) and a unique User ID(UID). In fact all components of an Android app run in the same process with the same PID and UID unless specified otherwise. Components in an Android app can be protected by permissions. If a component is protected by a permission then only components that are granted the permission are allowed to call that component. A permission can be enforced at compile time or at run time or both. If a permission is enforced at compile time then, components running in the same process as that of the *component protected by the permission* are granted the permission by default. But components running outside that process will have to request the Android system to grant permission to it. However, if the permission is enforced at run-time then all components irrespective of whether they run in the same process or not have to request the Android system to grant it permission. Android provides numerous API methods to help verify permissions at run-time. One of these methods is *checkCallingOrSelfPermission(String permission)* which returns true if permission has been granted to a component that runs in the same process as that of the *component protected by the permission* **or** if permission is granted to a component that *does not* run in the same process as that of the *component protected by the permission*. It returns false otherwise.


*Issue:* A component that uses run-time permission checking via *checkCallingOrSelfPermission* for access control, grants permission to **all** components if it grants permission even once to a component that runs in the same process as that of itself. If *checkCallingOrSelfPermission* is used to protect a component that performs a sensitive operation then it is possible for a malicious component running in a different process to escalate its privilege and access a component to which the malicious component did not have access to.  

*Example:* The vulnerability is demonstrated by *Benign* and *Malicious*. The benign app has a service *MyService* that performs a sensitive operation. The app's *MainActivity* requests the user for permission to start *MyService*. If the user grants the permission then *MainActivity* starts the service. *Malicious* is a malicious app that also attempts to start *Benign/MyService*. The attempt will be successful because *Benign/MyService* uses *checkCallingOrSelfPermission* which evaluates to true because permission was already granted to *Benign/MainActivity* before. Therefore, the malicious app can successfully perform a privilege escalation attack.


# Steps to build the sample apps and re-produce the exploit

1. list targets:

    `$ android list targets`

2. list available Android Virtual Devices:

    `$ android list avd`

3.  create an emulator:

    `$ android create avd -n <name> -t <target>`

    *<target>* is obtained from the command listed in 1. *<name>* is the name you choose to give to the avd.

4.  start emulator:

    `$ emulator -avd <avd_name>`

    *<avd-name>* is obtained from the command listed in 2.

5. build and install *Benign*:

    `$ cd Benign`

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk. Build will fail without this.

    `$ ./gradlew installDebug`

6.  build and install *Malicious*:

    `$ cd Malicious`

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk. Build will fail without this.

    `$ ./gradlew installDebug`

7. Launch *Malicious* in the emulator where it is installed.

8.  `adb logcat -d | grep "MyService"`

    You should see a message "do something important"

# References

1.  [Official Android Documentation](https://developer.android.com/reference/android/content/Context.html#checkCallingOrSelfPermission(java.lang.String))
