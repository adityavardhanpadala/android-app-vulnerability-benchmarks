# Summary
Apps that do not check for the validity of a Certificate Authority when communicating with a server are 
vulnerable to MITM attacks.   

# Android versions affected
Tested on Android 4.2 - Android 7.1

# Description of vulnerability and corresponding exploit
Android apps can use SSL/TLS to securely communicate with a web server. When an app wants to connect with 
a web server, it requests the web server for a certificate signed by a certificate authority that the app
trusts. How does the app know which Certificate Authority to trust? Every Android device comes with a 
list of pre-installed Certificate Authorities that it trusts. All apps running on that device inherit 
the trusted list of Certificate Authorities. If the server the app is trying to connect to is signed by 
a Certificate Authority not trusted by the Android device in which the app is running then the connection
is refused. This becomes a problem if the server is signed with a certificate that is not well known or
the server is self-signed. Android provides the TrustManager and SSLContext APIs to workaround this problem.
An app can implement its own TrustManager listing the certificates it trusts. It can then set these TrustManagers
in an SSLContext and use that SSLContext when communicating with a server using SSL/TLS.


*Issue:* Apps can be vulnerable if they incorrectly implement a TrustManager. A TrustManager can be
implemented by implementing the *X509TrustManager* interface and overriding the methods *checkClientTrusted()*,
*checkServerTrusted()* and *getAcceptedUsers()*. The method which checks whether a server is signed by 
a trusted Certificate Authority is *checkServerTrusted()*. If that implementations is left blank then
the app trusts *all* Certificate Authorities. This means that the app can end up connecting to a malcious
server signed by a fake Certificate Authority. The only correct way to implement a TrustManager is to create a 
key store, save all the trusted Certificate Authorities in it and check the certificate of the server
the app is connecting to with those stored in the key store.

*Example:* An example of such a vulnerability is shown in *ExploitAllowFileAccessWebView/Benign*. The app
connects to a server over TLS. The server is signed with a self-signed Certificate Authority not trusted
by any Android device and should refuse connection. However, the app implements a TrustManager *MyTrustManager.java* 
which is a blank implementation of the TrustManager interface. It successfully connects to the server. 
But any malicious server can create a fake Certificate Authority and connect to the app.


# Steps to re-produce the exploit automatically
Coming soon.



