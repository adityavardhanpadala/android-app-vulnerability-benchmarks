# Summary
Apps that incorrectly pin the certificates of servers they trust are
vulnerable to MITM attacks.   

# Android versions affected
Tested on Android 4.4 - Android 7.1

# Description of vulnerability and corresponding exploit
Android apps can use SSL/TLS to securely communicate with a web server. All apps running on that device inherit
the trusted list of Certificate Authorities. If an app wants to trust a server X, which is not trusted by trusted list of Certificate Authorities, then the app needs to store certificate of X in keystore for future reference. When app tries to connect to any server, it will check againts stored certificates. This is called *certificate pinning*. If an app incorrectly pins certificate of X, then it might end up trusting all the servers which are not trusted by list of Certificate Authorities.


*Issue:* Apps can be vulnerable if they incorrectly implement a certificate pinning. A TrustManager can be
implemented by implementing the *X509TrustManager* interface and overriding the methods *checkClientTrusted()*,
*checkServerTrusted()* and *getAcceptedUsers()*. If an app stores the certificate of X but incorrectly implements the *TrustManager* then the app can end up connecting to a malicious server signed by a fake Certificate Authority.

*Example:* The vulnerability is demonstrated by *Benign*. The app connects to a server over SSL/TLS. The server is signed with a self-signed Certificate Authority not trusted by any Android device and should refuse connection. However, the app works around this by storing the certificate in a keystore and implementing a TrustManager, *MyTrustManager.java* which is a *blank implementation of the TrustManager interface*, to successfully connect to the server. The local server in *Misc/LocalServer* is man-in-the-middle that masquerades as the server and is signed with a self signed certificate. Since, *Benign* incorrectly pins the certificate, *Misc/LocalServer* will also be able to connect to the app.

# Steps to build the sample apps and to exploit the vulnerability

1. Setup a local Web Server. We have used Flask here. If you want to use Flask follow the instructions [here](https://bitbucket.org/secure-it-i/android-app-vulnerability-benchmarks/src/76cc87180f064b328c37cc57b5c743dba378a5de/Misc/LocalServer/README.md?at=master&fileviewer=file-view-default).

2. List targets:

    `$ android list targets`

3. List available Android Virtual Devices:

    `$ android list avd`

4. Create an emulator:

    `$ android create avd -n <name> -t <target>`

    *<target>* is obtained from the command listed in 1. *<name>* is the name you choose to give to the avd.

5. Start emulator:

    `$ emulator -avd <avd_name>`

    *<avd-name>* is obtained from the command listed in 3.

6. Edit the *url* field in *Benign/.../res/values/strings.xml* to reflect the url of the web server where the html file being loaded is stored.

7. Build and install *Benign*:

    `$ cd Benign`

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk.

    `$ ./gradlew installDebug`

8. TextView will display response from local web server you setup:

    The web content displayed in the console demonstrates that *Benign* does not verify the Certificate Authority.

# References

1.  [Official Android Documentation](https://developer.android.com/training/articles/security-ssl#java)

2.  [To Pin or Not to Pin - Marten Oltrogge, Yasemin Acar, Sergej Dechand, Matthew Smith, Sascha Fahl](https://saschafahl.de/papers/pinnotpin2015.pdf)
